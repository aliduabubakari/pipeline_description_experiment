{
  "unique_key": "nazzang49/gcp-tutorials:composer/workflows/airflow_db_cleanup.py",
  "repo": "nazzang49/gcp-tutorials",
  "repo_url": "https://github.com/nazzang49/gcp-tutorials",
  "stars": 0,
  "license": "Apache-2.0",
  "file_path": "composer/workflows/airflow_db_cleanup.py",
  "detected_airflow_version": "unknown",
  "sampled_versions": [
    {
      "version": "latest",
      "commit": "d1d77c5a323daeeee90a9f40d5efd66a7d7a6b04",
      "code": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START composer_metadb_cleanup]\n\"\"\"\nA maintenance workflow that you can deploy into Airflow to periodically clean\nout the DagRun, TaskInstance, Log, XCom, Job DB and SlaMiss entries to avoid\nhaving too much data in your Airflow MetaStore.\n\n## Authors\n\nThe DAG is a fork of [teamclairvoyant repository.](https://github.com/teamclairvoyant/airflow-maintenance-dags/tree/master/db-cleanup)\n\n## Usage\n\n1. Update the global variables (SCHEDULE_INTERVAL, DAG_OWNER_NAME,\n  ALERT_EMAIL_ADDRESSES and ENABLE_DELETE) in the DAG with the desired values\n\n2. Modify the DATABASE_OBJECTS list to add/remove objects as needed. Each\n   dictionary in the list features the following parameters:\n    - airflow_db_model: Model imported from airflow.models corresponding to\n      a table in the airflow metadata database\n    - age_check_column: Column in the model/table to use for calculating max\n      date of data deletion\n    - keep_last: Boolean to specify whether to preserve last run instance\n        - keep_last_filters: List of filters to preserve data from deleting\n          during clean-up, such as DAG runs where the external trigger is set to 0.\n        - keep_last_group_by: Option to specify column by which to group the\n          database entries and perform aggregate functions.\n\n3. Create and Set the following Variables in the Airflow Web Server\n  (Admin -> Variables)\n    - airflow_db_cleanup__max_db_entry_age_in_days - integer - Length to retain\n      the log files if not already provided in the conf. If this is set to 30,\n      the job will remove those files that are 30 days old or older.\n\n4. Put the DAG in your gcs bucket.\n\"\"\"\nfrom datetime import timedelta\nimport logging\nimport os\n\nimport airflow\nfrom airflow import settings\nfrom airflow.models import (\n    DAG,\n    DagModel,\n    DagRun,\n    Log,\n    SlaMiss,\n    TaskInstance,\n    Variable,\n    XCom,\n)\nfrom airflow.operators.python import PythonOperator\nfrom airflow.utils import timezone\nfrom airflow.version import version as airflow_version\n\nimport dateutil.parser\nfrom sqlalchemy import and_, func, text\nfrom sqlalchemy.exc import ProgrammingError\nfrom sqlalchemy.orm import load_only\n\nnow = timezone.utcnow\n\n# airflow-db-cleanup\nDAG_ID = os.path.basename(__file__).replace(\".pyc\", \"\").replace(\".py\", \"\")\nSTART_DATE = airflow.utils.dates.days_ago(1)\n# How often to Run. @daily - Once a day at Midnight (UTC)\nSCHEDULE_INTERVAL = \"@daily\"\n# Who is listed as the owner of this DAG in the Airflow Web Server\nDAG_OWNER_NAME = \"operations\"\n# List of email address to send email alerts to if this job fails\nALERT_EMAIL_ADDRESSES = []\n# Airflow version used by the environment in list form, value stored in\n# airflow_version is in format e.g \"2.3.4+composer\"\nAIRFLOW_VERSION = airflow_version[: -len(\"+composer\")].split(\".\")\n# Length to retain the log files if not already provided in the conf. If this\n# is set to 30, the job will remove those files that arE 30 days old or older.\nDEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS = int(\n    Variable.get(\"airflow_db_cleanup__max_db_entry_age_in_days\", 30)\n)\n# Prints the database entries which will be getting deleted; set to False\n# to avoid printing large lists and slowdown process\nPRINT_DELETES = False\n# Whether the job should delete the db entries or not. Included if you want to\n# temporarily avoid deleting the db entries.\nENABLE_DELETE = True\n# List of all the objects that will be deleted. Comment out the DB objects you\n# want to skip.\nDATABASE_OBJECTS = [\n    {\n        \"airflow_db_model\": DagRun,\n        \"age_check_column\": DagRun.execution_date,\n        \"keep_last\": True,\n        \"keep_last_filters\": [DagRun.external_trigger.is_(False)],\n        \"keep_last_group_by\": DagRun.dag_id,\n    },\n    {\n        \"airflow_db_model\": TaskInstance,\n        \"age_check_column\": TaskInstance.start_date\n        if AIRFLOW_VERSION < [\"2\", \"2\", \"0\"]\n        else TaskInstance.start_date,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None,\n    },\n    {\n        \"airflow_db_model\": Log,\n        \"age_check_column\": Log.dttm,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None,\n    },\n    {\n        \"airflow_db_model\": XCom,\n        \"age_check_column\": XCom.execution_date\n        if AIRFLOW_VERSION < [\"2\", \"2\", \"5\"]\n        else XCom.timestamp,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None,\n    },\n    {\n        \"airflow_db_model\": SlaMiss,\n        \"age_check_column\": SlaMiss.execution_date,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None,\n    },\n    {\n        \"airflow_db_model\": DagModel,\n        \"age_check_column\": DagModel.last_parsed_time,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None,\n    },\n]\n\n# Check for TaskReschedule model\ntry:\n    from airflow.models import TaskReschedule\n\n    DATABASE_OBJECTS.append(\n        {\n            \"airflow_db_model\": TaskReschedule,\n            \"age_check_column\": TaskReschedule.execution_date\n            if AIRFLOW_VERSION < [\"2\", \"2\", \"0\"]\n            else TaskReschedule.start_date,\n            \"keep_last\": False,\n            \"keep_last_filters\": None,\n            \"keep_last_group_by\": None,\n        }\n    )\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for TaskFail model\ntry:\n    from airflow.models import TaskFail\n\n    DATABASE_OBJECTS.append(\n        {\n            \"airflow_db_model\": TaskFail,\n            \"age_check_column\": TaskFail.start_date,\n            \"keep_last\": False,\n            \"keep_last_filters\": None,\n            \"keep_last_group_by\": None,\n        }\n    )\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for RenderedTaskInstanceFields model\nif AIRFLOW_VERSION < [\"2\", \"4\", \"0\"]:\n    try:\n        from airflow.models import RenderedTaskInstanceFields\n\n        DATABASE_OBJECTS.append(\n            {\n                \"airflow_db_model\": RenderedTaskInstanceFields,\n                \"age_check_column\": RenderedTaskInstanceFields.execution_date,\n                \"keep_last\": False,\n                \"keep_last_filters\": None,\n                \"keep_last_group_by\": None,\n            }\n        )\n\n    except Exception as e:\n        logging.error(e)\n\n# Check for ImportError model\ntry:\n    from airflow.models import ImportError\n\n    DATABASE_OBJECTS.append(\n        {\n            \"airflow_db_model\": ImportError,\n            \"age_check_column\": ImportError.timestamp,\n            \"keep_last\": False,\n            \"keep_last_filters\": None,\n            \"keep_last_group_by\": None,\n            \"do_not_delete_by_dag_id\": True,\n        }\n    )\n\nexcept Exception as e:\n    logging.error(e)\n\nif AIRFLOW_VERSION < [\"2\", \"6\", \"0\"]:\n    try:\n        from airflow.jobs.base_job import BaseJob\n\n        DATABASE_OBJECTS.append(\n            {\n                \"airflow_db_model\": BaseJob,\n                \"age_check_column\": BaseJob.latest_heartbeat,\n                \"keep_last\": False,\n                \"keep_last_filters\": None,\n                \"keep_last_group_by\": None,\n            }\n        )\n    except Exception as e:\n        logging.error(e)\nelse:\n    try:\n        from airflow.jobs.job import Job\n\n        DATABASE_OBJECTS.append(\n            {\n                \"airflow_db_model\": Job,\n                \"age_check_column\": Job.latest_heartbeat,\n                \"keep_last\": False,\n                \"keep_last_filters\": None,\n                \"keep_last_group_by\": None,\n            }\n        )\n    except Exception as e:\n        logging.error(e)\n\ndefault_args = {\n    \"owner\": DAG_OWNER_NAME,\n    \"depends_on_past\": False,\n    \"email\": ALERT_EMAIL_ADDRESSES,\n    \"email_on_failure\": True,\n    \"email_on_retry\": False,\n    \"start_date\": START_DATE,\n    \"retries\": 1,\n    \"retry_delay\": timedelta(minutes=1),\n}\n\ndag = DAG(\n    DAG_ID,\n    default_args=default_args,\n    schedule_interval=SCHEDULE_INTERVAL,\n    start_date=START_DATE,\n)\nif hasattr(dag, \"doc_md\"):\n    dag.doc_md = __doc__\nif hasattr(dag, \"catchup\"):\n    dag.catchup = False\n\n\ndef print_configuration_function(**context):\n    logging.info(\"Loading Configurations...\")\n    dag_run_conf = context.get(\"dag_run\").conf\n    logging.info(\"dag_run.conf: \" + str(dag_run_conf))\n    max_db_entry_age_in_days = None\n    if dag_run_conf:\n        max_db_entry_age_in_days = dag_run_conf.get(\"maxDBEntryAgeInDays\", None)\n    logging.info(\"maxDBEntryAgeInDays from dag_run.conf: \" + str(dag_run_conf))\n    if max_db_entry_age_in_days is None or max_db_entry_age_in_days < 1:\n        logging.info(\n            \"maxDBEntryAgeInDays conf variable isn't included or Variable \"\n            + \"value is less than 1. Using Default '\"\n            + str(DEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS)\n            + \"'\"\n        )\n        max_db_entry_age_in_days = DEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS\n    max_date = now() + timedelta(-max_db_entry_age_in_days)\n    logging.info(\"Finished Loading Configurations\")\n    logging.info(\"\")\n\n    logging.info(\"Configurations:\")\n    logging.info(\"max_db_entry_age_in_days: \" + str(max_db_entry_age_in_days))\n    logging.info(\"max_date:                 \" + str(max_date))\n    logging.info(\"enable_delete:            \" + str(ENABLE_DELETE))\n    logging.info(\"\")\n\n    logging.info(\"Setting max_execution_date to XCom for Downstream Processes\")\n    context[\"ti\"].xcom_push(key=\"max_date\", value=max_date.isoformat())\n\n\nprint_configuration = PythonOperator(\n    task_id=\"print_configuration\",\n    python_callable=print_configuration_function,\n    provide_context=True,\n    dag=dag,\n)\n\n\ndef build_query(\n    session,\n    airflow_db_model,\n    age_check_column,\n    max_date,\n    keep_last,\n    keep_last_filters=None,\n    keep_last_group_by=None,\n):\n    query = session.query(airflow_db_model).options(load_only(age_check_column))\n\n    logging.info(\"INITIAL QUERY : \" + str(query))\n\n    if not keep_last:\n        query = query.filter(\n            age_check_column <= max_date,\n        )\n    else:\n        subquery = session.query(func.max(DagRun.execution_date))\n        # workaround for MySQL \"table specified twice\" issue\n        # https://github.com/teamclairvoyant/airflow-maintenance-dags/issues/41\n        if keep_last_filters is not None:\n            for entry in keep_last_filters:\n                subquery = subquery.filter(entry)\n\n            logging.info(\"SUB QUERY [keep_last_filters]: \" + str(subquery))\n\n        if keep_last_group_by is not None:\n            subquery = subquery.group_by(keep_last_group_by)\n            logging.info(\"SUB QUERY [keep_last_group_by]: \" + str(subquery))\n\n        subquery = subquery.from_self()\n\n        query = query.filter(\n            and_(age_check_column.notin_(subquery)), and_(age_check_column <= max_date)\n        )\n\n    return query\n\n\ndef print_query(query, airflow_db_model, age_check_column):\n    entries_to_delete = query.all()\n\n    logging.info(\"Query: \" + str(query))\n    logging.info(\n        \"Process will be Deleting the following \"\n        + str(airflow_db_model.__name__)\n        + \"(s):\"\n    )\n    for entry in entries_to_delete:\n        date = str(entry.__dict__[str(age_check_column).split(\".\")[1]])\n        logging.info(\"\\tEntry: \" + str(entry) + \", Date: \" + date)\n\n    logging.info(\n        \"Process will be Deleting \"\n        + str(len(entries_to_delete))\n        + \" \"\n        + str(airflow_db_model.__name__)\n        + \"(s)\"\n    )\n\n\ndef cleanup_function(**context):\n    session = settings.Session()\n\n    logging.info(\"Retrieving max_execution_date from XCom\")\n    max_date = context[\"ti\"].xcom_pull(\n        task_ids=print_configuration.task_id, key=\"max_date\"\n    )\n    max_date = dateutil.parser.parse(max_date)  # stored as iso8601 str in xcom\n\n    airflow_db_model = context[\"params\"].get(\"airflow_db_model\")\n    state = context[\"params\"].get(\"state\")\n    age_check_column = context[\"params\"].get(\"age_check_column\")\n    keep_last = context[\"params\"].get(\"keep_last\")\n    keep_last_filters = context[\"params\"].get(\"keep_last_filters\")\n    keep_last_group_by = context[\"params\"].get(\"keep_last_group_by\")\n\n    logging.info(\"Configurations:\")\n    logging.info(\"max_date:                 \" + str(max_date))\n    logging.info(\"enable_delete:            \" + str(ENABLE_DELETE))\n    logging.info(\"session:                  \" + str(session))\n    logging.info(\"airflow_db_model:         \" + str(airflow_db_model))\n    logging.info(\"state:                    \" + str(state))\n    logging.info(\"age_check_column:         \" + str(age_check_column))\n    logging.info(\"keep_last:                \" + str(keep_last))\n    logging.info(\"keep_last_filters:        \" + str(keep_last_filters))\n    logging.info(\"keep_last_group_by:       \" + str(keep_last_group_by))\n\n    logging.info(\"\")\n\n    logging.info(\"Running Cleanup Process...\")\n\n    try:\n        if context[\"params\"].get(\"do_not_delete_by_dag_id\"):\n            query = build_query(\n                session,\n                airflow_db_model,\n                age_check_column,\n                max_date,\n                keep_last,\n                keep_last_filters,\n                keep_last_group_by,\n            )\n            if PRINT_DELETES:\n                print_query(query, airflow_db_model, age_check_column)\n            if ENABLE_DELETE:\n                logging.info(\"Performing Delete...\")\n                query.delete(synchronize_session=False)\n            session.commit()\n        else:\n            dags = session.query(airflow_db_model.dag_id).distinct()\n            session.commit()\n\n            list_dags = [str(list(dag)[0]) for dag in dags] + [None]\n            for dag in list_dags:\n                query = build_query(\n                    session,\n                    airflow_db_model,\n                    age_check_column,\n                    max_date,\n                    keep_last,\n                    keep_last_filters,\n                    keep_last_group_by,\n                )\n                query = query.filter(airflow_db_model.dag_id == dag)\n                if PRINT_DELETES:\n                    print_query(query, airflow_db_model, age_check_column)\n                if ENABLE_DELETE:\n                    logging.info(\"Performing Delete...\")\n                    query.delete(synchronize_session=False)\n                session.commit()\n\n        if not ENABLE_DELETE:\n            logging.warn(\n                \"You've opted to skip deleting the db entries. \"\n                \"Set ENABLE_DELETE to True to delete entries!!!\"\n            )\n\n        logging.info(\"Finished Running Cleanup Process\")\n\n    except ProgrammingError as e:\n        logging.error(e)\n        logging.error(\n            str(airflow_db_model) + \" is not present in the metadata. \" \"Skipping...\"\n        )\n\n    finally:\n        session.close()\n\n\ndef cleanup_sessions():\n    session = settings.Session()\n\n    try:\n        logging.info(\"Deleting sessions...\")\n        before = len(\n            session.execute(\n                text(\"SELECT * FROM session WHERE expiry < now()::timestamp(0);\")\n            )\n            .mappings()\n            .all()\n        )\n        session.execute(text(\"DELETE FROM session WHERE expiry < now()::timestamp(0);\"))\n        after = len(\n            session.execute(\n                text(\"SELECT * FROM session WHERE expiry < now()::timestamp(0);\")\n            )\n            .mappings()\n            .all()\n        )\n        logging.info(\"Deleted {} expired sessions.\".format(before - after))\n    except Exception as e:\n        logging.error(e)\n\n    session.commit()\n    session.close()\n\n\ndef analyze_db():\n    session = settings.Session()\n    session.execute(\"ANALYZE\")\n    session.commit()\n    session.close()\n\n\nanalyze_op = PythonOperator(\n    task_id=\"analyze_query\", python_callable=analyze_db, provide_context=True, dag=dag\n)\n\ncleanup_session_op = PythonOperator(\n    task_id=\"cleanup_sessions\",\n    python_callable=cleanup_sessions,\n    provide_context=True,\n    dag=dag,\n)\n\ncleanup_session_op.set_downstream(analyze_op)\n\nfor db_object in DATABASE_OBJECTS:\n    cleanup_op = PythonOperator(\n        task_id=\"cleanup_\" + str(db_object[\"airflow_db_model\"].__name__),\n        python_callable=cleanup_function,\n        params=db_object,\n        provide_context=True,\n        dag=dag,\n    )\n\n    print_configuration.set_downstream(cleanup_op)\n    cleanup_op.set_downstream(analyze_op)\n\n# [END composer_metadb_cleanup]\n"
    },
    {
      "version": "earliest",
      "commit": "7ddc79165113b1f5465f470d696bad045c9f1c03",
      "code": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nA maintenance workflow that you can deploy into Airflow to periodically clean\nout the DagRun, TaskInstance, Log, XCom, Job DB and SlaMiss entries to avoid\nhaving too much data in your Airflow MetaStore.\n\n## Authors\n\nThe DAG is a fork of [teamclairvoyant repository.](https://github.com/teamclairvoyant/airflow-maintenance-dags/tree/master/db-cleanup)\n\n## Usage\n\n1. Update the global variables (SCHEDULE_INTERVAL, DAG_OWNER_NAME,\n  ALERT_EMAIL_ADDRESSES and ENABLE_DELETE) in the DAG with the desired values\n\n2. Modify the DATABASE_OBJECTS list to add/remove objects as needed. Each\n   dictionary in the list features the following parameters:\n    - airflow_db_model: Model imported from airflow.models corresponding to\n      a table in the airflow metadata database\n    - age_check_column: Column in the model/table to use for calculating max\n      date of data deletion\n    - keep_last: Boolean to specify whether to preserve last run instance\n        - keep_last_filters: List of filters to preserve data from deleting\n          during clean-up, such as DAG runs where the external trigger is set to 0.\n        - keep_last_group_by: Option to specify column by which to group the\n          database entries and perform aggregate functions.\n\n3. Create and Set the following Variables in the Airflow Web Server\n  (Admin -> Variables)\n    - airflow_db_cleanup__max_db_entry_age_in_days - integer - Length to retain\n      the log files if not already provided in the conf. If this is set to 30,\n      the job will remove those files that are 30 days old or older.\n\n4. Put the DAG in your gcs bucket.\n\"\"\"\nfrom datetime import datetime, timedelta\nimport logging\nimport os\n\nimport airflow\nfrom airflow import settings\nfrom airflow.configuration import conf\nfrom airflow.jobs import BaseJob\nfrom airflow.models import DAG, DagModel, DagRun, Log, SlaMiss, \\\n    TaskInstance, Variable, XCom\nfrom airflow.operators.python_operator import PythonOperator\nimport dateutil.parser\nfrom sqlalchemy import and_, func\nfrom sqlalchemy.exc import ProgrammingError\nfrom sqlalchemy.orm import load_only\n\ntry:\n    # airflow.utils.timezone is available from v1.10 onwards\n    from airflow.utils import timezone\n    now = timezone.utcnow\nexcept ImportError:\n    now = datetime.utcnow\n\n# airflow-db-cleanup\nDAG_ID = os.path.basename(__file__).replace(\".pyc\", \"\").replace(\".py\", \"\")\nSTART_DATE = airflow.utils.dates.days_ago(1)\n# How often to Run. @daily - Once a day at Midnight (UTC)\nSCHEDULE_INTERVAL = \"@daily\"\n# Who is listed as the owner of this DAG in the Airflow Web Server\nDAG_OWNER_NAME = \"operations\"\n# List of email address to send email alerts to if this job fails\nALERT_EMAIL_ADDRESSES = []\n# Length to retain the log files if not already provided in the conf. If this\n# is set to 30, the job will remove those files that arE 30 days old or older.\n\nDEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS = int(\n    Variable.get(\"airflow_db_cleanup__max_db_entry_age_in_days\", 30))\n# Prints the database entries which will be getting deleted; set to False\n# to avoid printing large lists and slowdown process\nPRINT_DELETES = False\n# Whether the job should delete the db entries or not. Included if you want to\n# temporarily avoid deleting the db entries.\nENABLE_DELETE = True\n# List of all the objects that will be deleted. Comment out the DB objects you\n# want to skip.\nDATABASE_OBJECTS = [{\n    \"airflow_db_model\": BaseJob,\n    \"age_check_column\": BaseJob.latest_heartbeat,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}, {\n    \"airflow_db_model\": DagRun,\n    \"age_check_column\": DagRun.execution_date,\n    \"keep_last\": True,\n    \"keep_last_filters\": [DagRun.external_trigger.is_(False)],\n    \"keep_last_group_by\": DagRun.dag_id\n}, {\n    \"airflow_db_model\": TaskInstance,\n    \"age_check_column\": TaskInstance.execution_date,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}, {\n    \"airflow_db_model\": Log,\n    \"age_check_column\": Log.dttm,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}, {\n    \"airflow_db_model\": XCom,\n    \"age_check_column\": XCom.execution_date,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}, {\n    \"airflow_db_model\": SlaMiss,\n    \"age_check_column\": SlaMiss.execution_date,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}, {\n    \"airflow_db_model\": DagModel,\n    \"age_check_column\": DagModel.last_scheduler_run,\n    \"keep_last\": False,\n    \"keep_last_filters\": None,\n    \"keep_last_group_by\": None\n}]\n\n# Check for TaskReschedule model\ntry:\n    from airflow.models import TaskReschedule\n    DATABASE_OBJECTS.append({\n        \"airflow_db_model\": TaskReschedule,\n        \"age_check_column\": TaskReschedule.execution_date,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None\n    })\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for TaskFail model\ntry:\n    from airflow.models import TaskFail\n    DATABASE_OBJECTS.append({\n        \"airflow_db_model\": TaskFail,\n        \"age_check_column\": TaskFail.execution_date,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None\n    })\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for RenderedTaskInstanceFields model\ntry:\n    from airflow.models import RenderedTaskInstanceFields\n    DATABASE_OBJECTS.append({\n        \"airflow_db_model\": RenderedTaskInstanceFields,\n        \"age_check_column\": RenderedTaskInstanceFields.execution_date,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None\n    })\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for ImportError model\ntry:\n    from airflow.models import ImportError\n    DATABASE_OBJECTS.append({\n        \"airflow_db_model\": ImportError,\n        \"age_check_column\": ImportError.timestamp,\n        \"keep_last\": False,\n        \"keep_last_filters\": None,\n        \"keep_last_group_by\": None\n    })\n\nexcept Exception as e:\n    logging.error(e)\n\n# Check for celery executor\nairflow_executor = str(conf.get(\"core\", \"executor\"))\nlogging.info(\"Airflow Executor: \" + str(airflow_executor))\nif (airflow_executor == \"CeleryExecutor\"):\n    logging.info(\"Including Celery Modules\")\n    try:\n        from celery.backends.database.models import Task, TaskSet\n        DATABASE_OBJECTS.extend(({\n            \"airflow_db_model\": Task,\n            \"age_check_column\": Task.date_done,\n            \"keep_last\": False,\n            \"keep_last_filters\": None,\n            \"keep_last_group_by\": None\n        }, {\n            \"airflow_db_model\": TaskSet,\n            \"age_check_column\": TaskSet.date_done,\n            \"keep_last\": False,\n            \"keep_last_filters\": None,\n            \"keep_last_group_by\": None\n        }))\n\n    except Exception as e:\n        logging.error(e)\n\nsession = settings.Session()\n\ndefault_args = {\n    \"owner\": DAG_OWNER_NAME,\n    \"depends_on_past\": False,\n    \"email\": ALERT_EMAIL_ADDRESSES,\n    \"email_on_failure\": True,\n    \"email_on_retry\": False,\n    \"start_date\": START_DATE,\n    \"retries\": 1,\n    \"retry_delay\": timedelta(minutes=1)\n}\n\ndag = DAG(\n    DAG_ID,\n    default_args=default_args,\n    schedule_interval=SCHEDULE_INTERVAL,\n    start_date=START_DATE)\nif hasattr(dag, \"doc_md\"):\n    dag.doc_md = __doc__\nif hasattr(dag, \"catchup\"):\n    dag.catchup = False\n\n\ndef print_configuration_function(**context):\n    logging.info(\"Loading Configurations...\")\n    dag_run_conf = context.get(\"dag_run\").conf\n    logging.info(\"dag_run.conf: \" + str(dag_run_conf))\n    max_db_entry_age_in_days = None\n    if dag_run_conf:\n        max_db_entry_age_in_days = dag_run_conf.get(\n            \"maxDBEntryAgeInDays\", None)\n    logging.info(\"maxDBEntryAgeInDays from dag_run.conf: \" + str(dag_run_conf))\n    if (max_db_entry_age_in_days is None or max_db_entry_age_in_days < 1):\n        logging.info(\n            \"maxDBEntryAgeInDays conf variable isn't included or Variable \" +\n            \"value is less than 1. Using Default '\" +\n            str(DEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS) + \"'\")\n        max_db_entry_age_in_days = DEFAULT_MAX_DB_ENTRY_AGE_IN_DAYS\n    max_date = now() + timedelta(-max_db_entry_age_in_days)\n    logging.info(\"Finished Loading Configurations\")\n    logging.info(\"\")\n\n    logging.info(\"Configurations:\")\n    logging.info(\"max_db_entry_age_in_days: \" + str(max_db_entry_age_in_days))\n    logging.info(\"max_date:                 \" + str(max_date))\n    logging.info(\"enable_delete:            \" + str(ENABLE_DELETE))\n    logging.info(\"session:                  \" + str(session))\n    logging.info(\"\")\n\n    logging.info(\"Setting max_execution_date to XCom for Downstream Processes\")\n    context[\"ti\"].xcom_push(key=\"max_date\", value=max_date.isoformat())\n\n\nprint_configuration = PythonOperator(\n    task_id=\"print_configuration\",\n    python_callable=print_configuration_function,\n    provide_context=True,\n    dag=dag)\n\n\ndef cleanup_function(**context):\n\n    logging.info(\"Retrieving max_execution_date from XCom\")\n    max_date = context[\"ti\"].xcom_pull(\n        task_ids=print_configuration.task_id, key=\"max_date\")\n    max_date = dateutil.parser.parse(max_date)  # stored as iso8601 str in xcom\n\n    airflow_db_model = context[\"params\"].get(\"airflow_db_model\")\n    state = context[\"params\"].get(\"state\")\n    age_check_column = context[\"params\"].get(\"age_check_column\")\n    keep_last = context[\"params\"].get(\"keep_last\")\n    keep_last_filters = context[\"params\"].get(\"keep_last_filters\")\n    keep_last_group_by = context[\"params\"].get(\"keep_last_group_by\")\n\n    logging.info(\"Configurations:\")\n    logging.info(\"max_date:                 \" + str(max_date))\n    logging.info(\"enable_delete:            \" + str(ENABLE_DELETE))\n    logging.info(\"session:                  \" + str(session))\n    logging.info(\"airflow_db_model:         \" + str(airflow_db_model))\n    logging.info(\"state:                    \" + str(state))\n    logging.info(\"age_check_column:         \" + str(age_check_column))\n    logging.info(\"keep_last:                \" + str(keep_last))\n    logging.info(\"keep_last_filters:        \" + str(keep_last_filters))\n    logging.info(\"keep_last_group_by:       \" + str(keep_last_group_by))\n\n    logging.info(\"\")\n\n    logging.info(\"Running Cleanup Process...\")\n\n    try:\n        query = session.query(airflow_db_model).options(\n            load_only(age_check_column))\n\n        logging.info(\"INITIAL QUERY : \" + str(query))\n\n        if keep_last:\n\n            subquery = session.query(func.max(DagRun.execution_date))\n            # workaround for MySQL \"table specified twice\" issue\n            # https://github.com/teamclairvoyant/airflow-maintenance-dags/issues/41\n            if keep_last_filters is not None:\n                for entry in keep_last_filters:\n                    subquery = subquery.filter(entry)\n\n                logging.info(\"SUB QUERY [keep_last_filters]: \" + str(subquery))\n\n            if keep_last_group_by is not None:\n                subquery = subquery.group_by(keep_last_group_by)\n                logging.info(\n                    \"SUB QUERY [keep_last_group_by]: \" +\n                    str(subquery))\n\n            subquery = subquery.from_self()\n\n            query = query.filter(\n                and_(age_check_column.notin_(subquery)),\n                and_(age_check_column <= max_date))\n\n        else:\n            query = query.filter(age_check_column <= max_date,)\n\n        if PRINT_DELETES:\n            entries_to_delete = query.all()\n\n            logging.info(\"Query: \" + str(query))\n            logging.info(\"Process will be Deleting the following \" +\n                         str(airflow_db_model.__name__) + \"(s):\")\n            for entry in entries_to_delete:\n                date = str(entry.__dict__[str(age_check_column).split(\".\")[1]])\n                logging.info(\"\\tEntry: \" + str(entry) + \", Date: \" + date)\n\n            logging.info(\"Process will be Deleting \"\n                         + str(len(entries_to_delete)) + \" \"\n                         + str(airflow_db_model.__name__) + \"(s)\")\n        else:\n            logging.warn(\n                \"You've opted to skip printing the db entries to be deleted. \"\n                \"Set PRINT_DELETES to True to show entries!!!\")\n\n        if ENABLE_DELETE:\n            logging.info(\"Performing Delete...\")\n            # using bulk delete\n            query.delete(synchronize_session=False)\n            session.commit()\n            logging.info(\"Finished Performing Delete\")\n        else:\n            logging.warn(\"You've opted to skip deleting the db entries. \"\n                         \"Set ENABLE_DELETE to True to delete entries!!!\")\n\n        logging.info(\"Finished Running Cleanup Process\")\n\n    except ProgrammingError as e:\n        logging.error(e)\n        logging.error(\n            str(airflow_db_model) + \" is not present in the metadata.\"\n            \"Skipping...\")\n\n\nfor db_object in DATABASE_OBJECTS:\n\n    cleanup_op = PythonOperator(\n        task_id=\"cleanup_\" + str(db_object[\"airflow_db_model\"].__name__),\n        python_callable=cleanup_function,\n        params=db_object,\n        provide_context=True,\n        dag=dag)\n\n    print_configuration.set_downstream(cleanup_op)\n"
    }
  ],
  "sampled_time": "2025-08-22T20:53:45.037610Z",
  "analysis": {
    "is_valid_dag_file": true,
    "is_production_dag": true,
    "is_airflow_2": true,
    "processing_type": "batch",
    "has_streaming_operators": false,
    "has_ml_operators": false,
    "topology": {
      "pattern": "linear",
      "has_sensors": false,
      "has_branches": false,
      "has_fan_out": false,
      "has_fan_in": false,
      "estimated_max_parallel_width": 1,
      "estimated_branch_depth": 0,
      "has_cycles": false,
      "has_subdags": false,
      "has_task_groups": false
    },
    "tasks": {
      "total_count": 2,
      "operator_types": [
        "PythonOperator"
      ],
      "has_dynamic_mapping": false,
      "has_external_task_sensor": false
    },
    "description": "Airflow database cleanup maintenance workflow that periodically removes old metadata entries from various Airflow database tables including DagRun, TaskInstance, Log, XCom, SlaMiss, and other models to prevent excessive data accumulation in the Airflow MetaStore.",
    "complexity_score": 3
  }
}